# 一、JS 的单线程特性

javaScript 语言的一大特点就是==单线程==，也就是同一个时间只能做一件事情。这就意味着，所有任务需要排队，前一个任务执行结束才会执行后一个任务。这样就会导致：如果 JS 执行的时间过长，就会造成页面渲染不连贯，导致页面渲染加载阻塞的感觉。

# 二、同步和异步

为了解决单线程问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 创建多个线程，于是，JS 中出现了==同步==和==异步==。

## 2.1 同步任务

前一个任务结束的再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。

同步任务都在主线程上执行，形成一个==执行栈==。

同步任务又叫**非耗时任务**

## 2.2 异步任务

执行一个任务时，因为这个任务执行时间较长，所以在这个期间，还可以去处理其它任务。异步任务也叫**耗时任务**

JS 的异步任务是通过回调函数实现的。

一般而言，异步任务有以下有三种类型

1. 普通事件，如 click，resize 等
2. 资源加载，如 load，error 等
3. 定时器，包括 setInterval、setTimeout 等

异步任务相关的回调函数将会被添加到==任务队列==中(任务队列也称消息队列)。

> 他们的本质区别：流水线上各个流程的执行顺序不同。

# 三、JS 执行机制 EventLoop

![](https://gitee.com/jaydensoong/imgsrc/raw/master/test.drawio.png)

1. 先执行执行栈中的同步任务。
2. 遇到异步任务(回调函数)就提交给对应的异步处理进程，由异步处理进程将其放到任务队列中。
3. 一旦执行栈中的所有同步任务执行完毕，系统就会按顺序读取任务队列中的异步任务，使被读取的异步任务结束等待状态，进行执行栈，开始执行。
4. 主线程会不断地查询任务队列，获取任务，再执行。这种机制被称为==事件循环(event loop)==。

可以这样理解：

![](https://gitee.com/jaydensoong/imgsrc/raw/master/lijie.png)

代码举例：

```javascript
// 显然地，下面代码的打印顺序是 1，2，3。
// 1. 主线程执行第一句，打印 1。
// 2. 执行第二句，定时器中的回调函数属于异步任务，由异步处理机制将其加入到队列中。
// 3. 执行第三句，打印 2。
// 4. 执行栈中的主线程执行完毕，开始检查任务队列中的任务，打印 3。
// 如果将定时器中的等待时间设置为0，执行顺序依然是一样的，只是不需要等待 1000 毫秒
console.log(1);
setTimeout(() => console.log(3), 1000);
//setTimeout(() => console.log(3), 0);
console.log(2);
```

```javascript
// 1. 主线程执行第一句，打印 1。
// 2. 事件监听中的回调函数也属于异步任务，由异步处理机制将其加入到队列中。
// 3. 执行第三句，打印 2。
// 4. 执行第四句，定时器中的回调函数属于异步任务，由异步处理机制将其加入到队列中
// 5. 执行栈中的主线程执行完毕，开始检查任务队列中的任务，打印 3。
// 主线程会反复查询任务队列，只要触发了 click，就会开始执行第二句中的回调函数。这个过程是循环的。
console.log(1);
document.addEventListener('click', () => console.log('click'));
console.log(2);
setTimeout(() => console.log(3), 1000);
```

# 